from datetime import datetime, timedelta
import re
from random import sample


# 1 Створіть функцію get_days_from_today(date), яка розраховує кількість днів між заданою датою і поточною датою.

def get_days_from_today(date: str) -> int:
    """
        Функція get_days_from_today отримує дату у форматі YYYY-mm-dd та вертає різницю
        у днях (ціле число) між сьогоднішньою датою та датою, яка отримана
    """    
    today = datetime.today()
    # Обробка винятків, якщо введена дата не відповідає необхідному формату
    try:
        date_obj = datetime.strptime(date, '%Y-%m-%d')
        return (today - date_obj).days
    except ValueError:
        return 'Невірний формат дати. Введіть дату у форматі YYYY-mm-dd'
    
print(get_days_from_today('2021-10-09'))


# 2 Необхідно написати функцію get_numbers_ticket(min, max, quantity), яка допоможе генерувати набір унікальних 
# випадкових чисел для таких лотерей.

def get_numbers_ticket(min: int, max: int, quantity: int) -> list:
    """
    Функція get_numbers_ticket(min, max, quantity), генерує набір унікальних випадкових чисел.
    Вона повертає випадковий набір чисел у межах заданих параметрів, причому всі випадкові числа в наборі унікальні.
    Параметри функції:
        min - мінімальне можливе число у наборі (не менше 1).
        max - максимальне можливе число у наборі (не більше 1000).
        quantity - кількість чисел, які потрібно вибрати (значення між min і max).
        Функція генерує вказану кількість унікальних чисел у заданому діапазоні.
        Функція повертає список випадково вибраних, відсортованих чисел. Числа в наборі не повинні повторюватися. 
        Якщо параметри не відповідають заданим обмеженням, функція повертає пустий список.
    """
    # Перевірка аргументів у відповідності до мимок. Аргументи повинні бути цілими числами, min - не меньше 1, max - не быльше 1000
    if all([type(el) == int for el in (min, max, quantity)]) \
        and (0 < min < max <= 1000) \
        and max - min >= quantity:
        return sorted(sample(range(min, max+1), k=quantity)) # результат відсортований список рандомних унікальних чисел 
    else:
        return [] # результат якщо аргументи не пройшли перевірку
    
    
     
    
print([get_numbers_ticket(*el) for el in ((-10, 10, 5), (1000, 1200, 10), (10, 4, 5), (10,14,6))])


# 3 Розробіть функцію normalize_phone(phone_number), що нормалізує телефонні номери до стандартного формату

def normalize_phone(phone_number: str) -> str:
    """
    Функція normalize_phone(phone_number), яка нормалізує телефонні номери до стандартного формату, 
    залишаючи тільки цифри та символ '+' на початку.
    
    Параметр функції phone_number - це рядок з телефонним номером у різноманітних форматах.
    Функція видаляє всі символи, крім цифр та символу '+'.
    
    Якщо міжнародний код відсутній, функція додає код '+38'. Це враховує випадки, коли номер починається з '380' (додається лише '+') 
    та коли номер починається без коду (додається '+38').
    
    Функція повертає нормалізований телефонний номер у вигляді рядка.
    """
    
    pattern = r'[^\+0-9]'
    new_phone_number = re.sub(pattern, '', phone_number) #залишаємо тільки цифри та знак +
    
    if new_phone_number[0] == '0': #перевіряємо якщо міжнародний код відсутній
        new_phone_number = f'+38{new_phone_number}' #додаємо код '+38'
    elif new_phone_number[:3] == '380': #перевіряємо якщо номер починається з '380'
        new_phone_number = f'+{new_phone_number}' #додаємо код '+'
        
    return new_phone_number

raw_numbers = [
    "067\\t123 4567",
    "(095) 234-5678\\n",
    "+380 44 123 4567",
    "380501234567",
    "    +38(050)123-32-34",
    "     0503451234",
    "(050)8889900",
    "38050-111-22-22",
    "38050 111 22 11   ",
]

sanitized_numbers = [normalize_phone(num) for num in raw_numbers]
print("Нормалізовані номери телефонів для SMS-розсилки:", sanitized_numbers)
    